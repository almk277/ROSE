ROSE is a stack machine. All instructions have zero or one argument,
although there might be implicit arguments on stack.

All instructions are 2 bytes long. First byte is opcode, and second one
is operand (if it is used).
Any instruction name in this document is prefixed with "%" sign. Any operand
reference is prefixed with "$" sign. For example, "$data" record means that
instruction under consideration contains operand with data index (that is,
index into data table). Prefix "." means segment name (".data", for example).
@top is stack top word. @base is stack frame base.

				Stack

Stack is a main storage for 32-bit words. Every method has it's own stack frame.
The first part of this frame is a locale variables storage (up to 255 words),
it's size is fixed for every method. The second part is a work area, and it's
size is changing dynamically. [%gets, %puts]

				Data types

There are two data types: small number and reference to object.

				Numbers

Numbers are 32-bits signed integers. Programmer can do some arighmetic with
them:
	* addition %add, substraction %sub.

				Arrays

There are fast arrays with random access.
	* creation %arrnew;
	* deletion %arrdel;
	* element access %arrget, %arrput;
	* getting length %arrlen.

				Constants

There are of the following types constant types:
	* embedded constants are instruction operands; [%pushc, %pushcsh]
	* constants are placed in .const; [%getc]
	* constant initialized arrays are placed in .str. [%arrload]

				Execution flow

There is three jump types:
	* near jump. It's destination must be no more than 127 instructions from
	  jump instruction; [%jump]
	* conditional jumps. They all are near jumps too, but jump happens only
	  on some condition. They pops one stack word [%jumpz, %jumpl, %jumple] or
	  two stack words [%jumpeq] and makes jump on some condition;
	* far jump can make jump to any address, but there must be no more than
	  255 far jumps on module.

				Methods

The same as functions or procedures.
It is an independent code fragment in some module.

To make procedure call, user pushes it's arguments on stack, then module
index (in .mtbl), and then call instruction follows.
[%call, %farcall]
To return execution flow, one must use return instruction. [%return, %retp]
It returns execution flow to instruction just after last call. Stack is
returned to the same state, but if it is procedure with return value, is must
be placed on @base (1st argument place), and return will leave it on stack
top.

				Objects
[OBSOLETE]
Object is a module instance. It has it's own data and other module segments
associated with it. It must be created and deleted then. [%new, %delete]
	* data are placed in .data. It is read/write storage, which exists while
	  the module instance does; [%getd, %putd]


				Miscellaneous

NOP instruction might be used for alignment purpose. [%nop]
